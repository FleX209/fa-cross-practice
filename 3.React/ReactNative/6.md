| group   |     token  |
|wff-cohort-1	| e1ed57ff-779c-48f1-9530-b8dff13e46b9 |																							

```bash
curl --location 'https://mesto.nomoreparties.co/v1/wff-cohort-1/cards?_id=be23c6910b1b927ebfd495da' \
--header 'authorization: e1ed57ff-779c-48f1-9530-b8dff13e46b9'
```

```js
const myHeaders = new Headers();
myHeaders.append("authorization", "e1ed57ff-779c-48f1-9530-b8dff13e46b9");

const urlencoded = new URLSearchParams();

const requestOptions = {
  method: "GET",
  headers: myHeaders,
  body: urlencoded,
  redirect: "follow"
};

fetch("https://mesto.nomoreparties.co/v1/wff-cohort-1/cards?_id=be23c6910b1b927ebfd495da", requestOptions)
  .then((response) => response.text())
  .then((result) => console.log(result))
  .catch((error) => console.error(error));
```

2. Перед стартом. Как сделать запрос к серверу
Адрес сервера проекта Mesto: https://mesto.nomoreparties.co.
При каждом запросе нужно передавать токен и идентификатор группы. Вот пример запроса одного студента из группы с идентификатором cohort-42:
return fetch('https://nomoreparties.co/v1/cohort-42/cards', {
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6'
  }
})
  .then(res => res.json())
  .then((result) => {
    console.log(result);
  }); 
Обратите внимание, что при запросе нужно передавать токен в заголовке authorization. Это необходимое условие. Если не передать серверу токен или передать неправильный — сервер ответит ошибкой. Делайте это в каждом запросе.
Идентификатор группы должен быть в URL сразу после v1. Всегда обращайтесь к своей группе. Если обратиться к чужой, сервер вернёт ошибку.
3. Загрузка информации о пользователе с сервера
Информация о пользователе должна подгружаться с сервера. Чтобы осуществить это, сделайте GET-запрос на URL (cohortId замените на идентификатор вашей группы):
GET https://nomoreparties.co/v1/cohortId/users/me 
При запросе не забудьте передать токен. Если запрос прошёл успешно, в ответе вы получите объект пользователя:
{
  "name": "Jacques Cousteau",
  "about": "Sailor, researcher",
  "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
  "_id": "e20537ed11237f86bbb20ccb",
  "cohort": "cohort0"
} 
Используйте свойства name, about и avatar в соответствующих элементах шапки страницы. Свойство _id — идентификатор пользователя, в данном случае вашего.
4. Загрузка карточек с сервера
Начальные карточки должны подгружаться с сервера. Для этого сделайте GET-запрос:
GET https://nomoreparties.co/v1/cohortId/cards 
В ответ придёт JSON с массивом карточек, которые загрузили студенты вашей группы:
[
  {
    "likes": [],
    "_id": "5d1f0611d321eb4bdcd707dd",
    "name": "Байкал",
    "link": "https://pictures.s3.yandex.net/frontend-developer/cards-compressed/baikal.jpg",
    "owner": {
      "name": "Jacques Cousteau",
      "about": "Sailor, researcher",
      "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
      "_id": "ef5f7423f7f5e22bef4ad607",
      "cohort": "local"
    },
    "createdAt": "2019-07-05T08:10:57.741Z"
  },
  {
    "likes": [],
    "_id": "5d1f064ed321eb4bdcd707de",
    "name": "Архыз",
    "link": "https://pictures.s3.yandex.net/frontend-developer/cards-compressed/arkhyz.jpg",
    "owner": {
      "name": "Jacques Cousteau",
      "about": "Sailor, researcher",
      "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
      "_id": "ef5f7423f7f5e22bef4ad607",
      "cohort": "local"
    },
    "createdAt": "2019-07-05T08:11:58.324Z"
  }
] 
Массив начальных карточек с шестью карточками, который вы использовали ранее, теперь можно удалить. Вместо него используйте массив, полученный с сервера.
Обратите внимание, вы будете получать только карточки, созданные студентами вашей группы. Значит, если вы первым выполните загрузку карточек с сервера, то получите пустой массив, это нормально. Создайте побольше новых карточек на сервере, чтобы ваши однокурсники увидели их.
У каждой карточки есть свойства name и link — это заголовок и ссылка на картинку. Они понадобятся при отображении каждой отдельной карточки.
Как видите, у карточки также есть идентификатор — свойство _id. Пока он вам не нужен, но скоро понадобится.
5. Редактирование профиля
Отредактированные данные профиля должны сохраняться на сервере. Для этого отправьте запрос методом PATCH:
PATCH https://nomoreparties.co/v1/cohortId/users/me 
В заголовках запроса, кроме токена, необходимо отправить Content-Type, а в теле — JSON с двумя свойствами — name и about. Значениями этих свойств должны быть обновлённые данные пользователя. Вот пример такого запроса:
fetch('https://nomoreparties.co/v1/cohortId/users/me', {
  method: 'PATCH',
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'Marie Skłodowska Curie',
    about: 'Physicist and Chemist'
  })
}); 
Если обновление прошло успешно, в теле ответа от сервера вы получите обновлённые данные пользователя:
{
  "name": "Marie Skłodowska Curie",
  "about": "Physicist and Chemist",
  "avatar": "https://pictures.s3.yandex.net/frontend-developer/common/ava.jpg",
  "_id": "e20537ed11237f86bbb20ccb",
  "cohort": "cohort0",
} 
Метод PATCH обычно используют для обновления сущностей, уже существующих на сервере. Обновление информации о пользователе — именно такой случай: пользователь уже есть, нужно просто обновить его данные.
6. Добавление новой карточки
Чтобы добавить на сервер новую карточку, отправьте POST-запрос:
POST https://nomoreparties.co/v1/cohortId/cards 
В заголовках запроса, кроме токена, необходимо отправить Content-Type, а в теле — JSON с двумя свойствами — name и link. В name должно быть название создаваемой карточки, а в link — ссылка на картинку. Если запрос прошёл успешно, сервер вернёт ответ с объектом новой карточки:
  {
    "likes": [],
    "_id": "5d1f0611d321eb4bdcd707dd",
    "name": "Байкал",
    "link": "https://pictures.s3.yandex.net/frontend-developer/cards-compressed/baikal.jpg",
    "owner": {
      "name": "Jacques Cousteau",
      "about": "Sailor, researcher",
      "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
      "_id": "ef5f7423f7f5e22bef4ad607",
      "cohort": "local"
    },
    "createdAt": "2019-07-05T08:10:57.741Z"
  }, 
7. Отображение количества лайков карточки
У каждой карточки есть свойство likes — оно содержит массив пользователей, лайкнувших карточку:
{
  "likes": [],
  ...другие данные карточки
} 
Сделайте так, чтобы на каждой карточке было написано, сколько у неё лайков:


Это выглядит так
Для этого придётся сверстать дополнительный элемент. Его дизайн есть в Figma.
8. Удаление карточки
Прежде чем браться за работу с API, исправьте элемент карточки. Сделайте так, чтобы иконка удаления была только на созданных вами карточках, так как удалять чужие карточки нельзя.


Если карточка создана не вами, на ней нет иконки корзины
После этого реализуйте функциональность удаления карточки. Карточка должна удаляться, если пользователь нажал на кнопку корзины. Обратите внимание, если попытаться удалить чужую карточку, то сервер не выполнит эту команду и вернёт ошибку.
Чтобы удалить карточку, отправьте DELETE-запрос:
DELETE https://nomoreparties.co/v1/cohortId/cards/cardId 
Вместо cardId в URL нужно подставить параметр _id карточки, которую нужно удалить. _id каждой карточки есть в её JSON:
{
  "likes": [],
  "_id": "5d1f0611d321eb4bdcd707dd", — вот он
  ...другие данные карточки
} 
В результате запрос на удаление этой карточки должен выглядеть так:
DELETE https://nomoreparties.co/v1/cohortId/cards/5d1f0611d321eb4bdcd707dd 
9. Постановка и снятие лайка
Чтобы лайкнуть карточку, отправьте PUT-запрос:
PUT https://nomoreparties.co/v1/cohortId/cards/likes/cardId 
Чтобы убрать лайк, нужно отправить DELETE-запрос с тем же URL:
DELETE https://nomoreparties.co/v1/cohortId/cards/likes/cardId 
Вместо cardId в URL нужно подставить свойство _id соответствующей карточки.
В ответе придёт обновлённый JSON с карточкой. Массив лайков в нём будет уже обновлён.
При постановке и снятии лайка сердечко должно менять цвет, а счётчик лайков увеличиваться или уменьшаться.
Чтобы изменить количество лайков, нужно отправить на сервер запрос с соответствующим методом. Рекомендуем брать количество лайков из ответа сервера, а не из вёрстки. Иначе могут возникнуть ошибки, когда два пользователя одновременно лайкнут одну карточку.
10. Обновление аватара пользователя
Чтобы сменить аватар, отправьте такой PATCH-запрос:
PATCH https://nomoreparties.co/v1/cohortId/users/me/avatar 
В теле запроса передайте JSON с единственным свойством — avatar. Это свойство должно хранить ссылку на новый аватар. Если отправить не ссылку, сервер вернёт ошибку.
При наведении указателя мыши на аватар, на нём должна появляться иконка редактирования:

А при клике — открываться форма. Эту форму нужно сделать. В ней должно быть одно поле — ссылка на новый аватар. Создавайте попап с новой формой по примеру уже имеющихся в разметке с использованием тех же классов и элементов разметки, чтобы все универсальные функции так же работали с этим новым попапом.

Иконка редактирования аватара и форма загрузки есть в Figma.
11. Улучшенный UX всех форм
Поработайте над UX. При редактировании профиля уведомите пользователя о процессе загрузки, поменяв текст кнопки на: «Сохранение...», пока данные загружаются:

Сделайте то же самое для формы добавления новой карточки и обновления аватара.
После окончания обмена данными с сервером, значение текста кнопки должно быть возвращено к исходному. Обратите внимание, что в случае, если при обмене данными с сервером возникла ошибка, модальное окно с заполненными полями форм должно остаться открытым, а текст на кнопке измениться на исходный. Этот функционал необходим для того, чтобы пользователь, в случае ошибки отправки запроса на сервер, мог повторить попытку.
Для корректной работы этого функционала следует помнить правило: Все изменения в разметке сайта (создание карточек, изменение лайка, закрытие попапов …) выполняются только в блоке then обработки запроса, чтобы все изменения на сайте происходили только после получения положительного ответа от сервера. При этом восстанавливать текст на кнопке формы нужно в блоке finally, чтобы текст изменился, даже если при общении с сервером произошла ошибка.
12. Требования к коду
Для работы с API создайте файл api.js. Все запросы присвойте переменным и экспортируйте их. В других модулях вы сможете импортировать эти функции и вызывать их. Вот небольшой пример того, как можно обустроить код в файле api.js:
const config = {
  baseUrl: 'https://nomoreparties.co/v1/cohort-42',
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6',
    'Content-Type': 'application/json'
  }
}

export const getInitialCards = () => {
    return fetch('', {})
    // ...
} 
13. Общие комментарии
1. Не забывайте проверять, всё ли в порядке с ответом. Для этого можно использовать res.ok или res.status:
const config = {
  baseUrl: 'https://nomoreparties.co/v1/cohort-42',
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6',
    'Content-Type': 'application/json'
  }
}

export const getInitialCards = () => {
  return fetch(`${config.baseUrl}/cards`, {
    headers: config.headers
  })
    .then(res => {
      if (res.ok) {
        return res.json();
      }
    });
} 
2. Учитывайте случай, когда сервер вернул ошибку:
const config = {
  baseUrl: 'https://nomoreparties.co/v1/cohort-42',
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6',
    'Content-Type': 'application/json'
  }
}

export const getInitialCards = () => {
  return fetch(`${config.baseUrl}/cards`, {
    headers: config.headers
  })
    .then(res => {
      if (res.ok) {
        return res.json();
      }

      // если ошибка, отклоняем промис
      return Promise.reject(`Ошибка: ${res.status}`);
    });
} 
3. Обрабатывайте ошибки, которые попадают в catch. Если запрос не ушёл на сервер или тот не ответил, сработает блок catch. Обрабатывайте ошибку внутри этого блока. Если нет времени писать сложную логику, просто выведите ошибку в консоль:
import { getInitialCards } from './api.js'

getInitialCards()
  .then((result) => {
    // обрабатываем результат
  })
  .catch((err) => {
    console.log(err); // выводим ошибку в консоль
  }); 
4. Пользуйтесь вкладкой Network для просмотра запросов. При отправке запросов держите вкладку Network открытой. Отфильтруйте в ней XHR запросы. Это позволит оперативно следить, что приходит в ответе от сервера.
